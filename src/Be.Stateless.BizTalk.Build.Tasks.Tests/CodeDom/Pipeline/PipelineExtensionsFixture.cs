#region Copyright & License

// Copyright © 2012 - 2022 François Chabot
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#endregion

using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Be.Stateless.BizTalk.Component;
using Be.Stateless.BizTalk.Dsl.Pipeline;
using Be.Stateless.BizTalk.Dsl.Pipeline.Xml.Serialization;
using Be.Stateless.BizTalk.Dummies;
using Be.Stateless.IO.Extensions;
using Be.Stateless.Resources;
using FluentAssertions;
using Microsoft.BizTalk.Component;
using Microsoft.CSharp;
using Xunit;

namespace Be.Stateless.BizTalk.CodeDom.Pipeline
{
	public class PipelineExtensionsFixture
	{
		[Theory]
		[InlineData(typeof(FFReceive))]
		[InlineData(typeof(PassThruReceive))]
		[InlineData(typeof(XmlReceive))]
		[InlineData(typeof(XmlRegularPipeline))]
		public void ReceivePipelinesCompileToDynamicAssembly(Type pipelineType)
		{
			var assembly = pipelineType.CompileToDynamicAssembly();
			assembly.CreateInstance(pipelineType.FullName!)
				.Should().NotBeNull()
				.And.BeAssignableTo<Microsoft.BizTalk.PipelineOM.ReceivePipeline>();
		}

		[Theory]
		[InlineData(typeof(FFTransmit))]
		[InlineData(typeof(PassThruTransmit))]
		[InlineData(typeof(XmlMicroPipeline))]
		[InlineData(typeof(XmlTransmit))]
		public void SendPipelinesCompileToDynamicAssembly(Type pipelineType)
		{
			var assembly = pipelineType.CompileToDynamicAssembly();
			assembly.CreateInstance(pipelineType.FullName!)
				.Should().NotBeNull()
				.And.BeAssignableTo<Microsoft.BizTalk.PipelineOM.SendPipeline>();
		}

		[Fact]
		public void XmlMicroPipelineConvertsToCodeCompileUnit()
		{
			var pipeline = new XmlMicroPipeline { VersionDependentGuid = Guid.Parse("55a6e50d-1750-4ccd-8995-e5151b049a01") };

			var builder = new StringBuilder();
			using (var provider = new CSharpCodeProvider())
			using (var writer = new StringWriter(builder))
			{
				provider.GenerateCodeFromCompileUnit(
					pipeline.ConvertToPipelineRuntimeCodeCompileUnit(),
					writer,
					new() { BracingStyle = "C", IndentString = "\t", VerbatimOrder = true });
			}

			// be resilient to runtime version in CodeDom heading comment
			Regex.Replace(builder.ToString(), @"(//\s+)Runtime Version:\d\.\d\.\d+\.\d+", @"$1Runtime Version:4.0.30319.42000", RegexOptions.Multiline)
				.Should().Be(
					ResourceManager.Load(
						Assembly.GetExecutingAssembly(),
						"Be.Stateless.BizTalk.Resources.Pipeline.XmlMicroPipeline.btp.cs",
						// be resilient to XML Schema and Instance namespace declaration order by reusing pipeline runtime document as generated by the build server
						s => s.ReadToEnd()).Replace("$$PipelineRuntimeDocument$$", pipeline.GetPipelineRuntimeDocumentSerializer().Serialize()));
		}

		[Fact]
		public void XmlRegularPipelineConvertsToCodeCompileUnit()
		{
			var pipeline = new XmlRegularPipeline { VersionDependentGuid = Guid.Parse("55a6e50d-1750-4ccd-8995-e5151b049a01") };

			var builder = new StringBuilder();
			using (var provider = new CSharpCodeProvider())
			using (var writer = new StringWriter(builder))
			{
				provider.GenerateCodeFromCompileUnit(
					pipeline.ConvertToPipelineRuntimeCodeCompileUnit(),
					writer,
					new() { BracingStyle = "C", IndentString = "\t", VerbatimOrder = true });
			}

			// be resilient to runtime version in CodeDom heading comment
			Regex.Replace(builder.ToString(), @"(//\s+)Runtime Version:\d\.\d\.\d+\.\d+", @"$1Runtime Version:4.0.30319.42000", RegexOptions.Multiline)
				.Should().Be(
					ResourceManager.Load(
						Assembly.GetExecutingAssembly(),
						"Be.Stateless.BizTalk.Resources.Pipeline.XmlRegularPipeline.btp.cs",
						// be resilient to XML Schema and Instance namespace declaration order by reusing pipeline runtime document as generated by the build server
						s => s.ReadToEnd()).Replace("$$PipelineRuntimeDocument$$", pipeline.GetPipelineRuntimeDocumentSerializer().Serialize()));
		}
	}

	internal class FFReceive : ReceivePipeline
	{
		public FFReceive()
		{
			Description = "Flat-File receive micro-pipeline.";
			Version = new(1, 0);
			Stages.Decode
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
			Stages.Disassemble
				.AddComponent(
					new FFDasmComp {
						DocumentSpecName = new(typeof(Microsoft.XLANGs.BaseTypes.Any).AssemblyQualifiedName),
						ValidateDocumentStructure = true
					});
			Stages.Validate
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}

	internal class FFTransmit : SendPipeline
	{
		public FFTransmit()
		{
			Description = "Flat-File send micro-pipeline.";
			Version = new(1, 0);
			Stages.PreAssemble
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
			Stages.Assemble
				.AddComponent(new FFAsmComp());
			Stages.Encode
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}

	internal class PassThruReceive : ReceivePipeline
	{
		public PassThruReceive()
		{
			Description = "Pass-through receive micro-pipeline.";
			Version = new(1, 0);
			Stages.Decode
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}

	internal class PassThruTransmit : SendPipeline
	{
		public PassThruTransmit()
		{
			Description = "Pass-through send micro-pipeline.";
			Version = new(1, 0);
			Stages.PreAssemble
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}

	internal class XmlReceive : ReceivePipeline
	{
		public XmlReceive()
		{
			Description = "XML receive micro-pipeline.";
			Version = new(1, 0);
			Stages.Decode
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
			Stages.Disassemble
				.AddComponent(new XmlDasmComp());
			Stages.Validate
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}

	internal class XmlTransmit : SendPipeline
	{
		public XmlTransmit()
		{
			Description = "XML send micro-pipeline.";
			Version = new(1, 0);
			Stages.PreAssemble
				.AddComponent(new FailedMessageRoutingEnablerComponent())
				.AddComponent(new MicroPipelineComponent { Enabled = true });
			Stages.Assemble
				.AddComponent(new XmlAsmComp());
			Stages.Encode
				.AddComponent(new MicroPipelineComponent { Enabled = true });
		}
	}
}
